import { AptosAccount, AptosClient, TxnBuilderTypes, BCS } from "aptos";
import * as fs from "fs";
import * as path from "path";

const NODE_URL = "https://fullnode.testnet.aptoslabs.com/v1";
const FAUCET_URL = "https://faucet.testnet.aptoslabs.com";

class FlowPayDeployer {
  private client: AptosClient;
  private account: AptosAccount;

  constructor() {
    this.client = new AptosClient(NODE_URL);
    
    // Load or create deployer account
    const privateKeyPath = path.join(__dirname, '../.aptos/config/deployer_key');
    
    if (fs.existsSync(privateKeyPath)) {
      const privateKeyHex = fs.readFileSync(privateKeyPath, 'utf8').trim();
      this.account = new AptosAccount(new Uint8Array(Buffer.from(privateKeyHex, 'hex')));
      console.log('üìã Loaded existing deployer account:', this.account.address().hex());
    } else {
      this.account = new AptosAccount();
      console.log('üÜï Created new deployer account:', this.account.address().hex());
      
      // Save private key
      fs.mkdirSync(path.dirname(privateKeyPath), { recursive: true });
      fs.writeFileSync(privateKeyPath, Buffer.from(this.account.signingKey.secretKey).toString('hex'));
      console.log('üíæ Saved private key to:', privateKeyPath);
    }
  }

  async fundAccount() {
    console.log('üí∞ Funding deployer account...');
    
    try {
      const response = await fetch(`${FAUCET_URL}/mint?amount=100000000&address=${this.account.address().hex()}`, {
        method: 'POST'
      });
      
      if (response.ok) {
        console.log('‚úÖ Account funded successfully');
        await this.waitForBalance();
      } else {
        console.log('‚ö†Ô∏è Faucet request failed, checking existing balance...');
        await this.waitForBalance();
      }
    } catch (error) {
      console.log('‚ö†Ô∏è Faucet error, checking existing balance...');
      await this.waitForBalance();
    }
  }

  async waitForBalance() {
    let attempts = 0;
    while (attempts < 10) {
      try {
        const balance = await this.client.getAccountBalance(this.account.address());
        console.log(`üí∞ Current balance: ${balance} octas (${balance / 100000000} APT)`);
        
        if (balance > 1000000) { // At least 0.01 APT
          return;
        }
      } catch (error) {
        console.log('‚è≥ Waiting for account to be created...');
      }
      
      await new Promise(resolve => setTimeout(resolve, 2000));
      attempts++;
    }
    
    throw new Error('Failed to fund account after multiple attempts');
  }

  async compileAndDeploy() {
    console.log('üî® Compiling Move modules...');
    
    // In a real deployment, you would compile the Move modules here
    // For now, we'll create the deployment transactions manually
    
    const modules = [
      'payment_router',
      'forex_engine', 
      'treasury_vault',
      'compliance_oracle',
      'settlement_bridge'
    ];

    const deployedAddresses: Record<string, string> = {};

    for (const moduleName of modules) {
      console.log(`üì¶ Deploying ${moduleName}...`);
      
      try {
        // Read compiled module bytecode (this would be generated by Move compiler)
        const modulePath = path.join(__dirname, `../build/${moduleName}.mv`);
        
        if (!fs.existsSync(modulePath)) {
          console.log(`‚ö†Ô∏è Module ${moduleName} not found, skipping...`);
          continue;
        }

        const moduleBytes = fs.readFileSync(modulePath);
        
        // Create deployment transaction
        const payload = new TxnBuilderTypes.TransactionPayloadEntryFunction(
          TxnBuilderTypes.EntryFunction.natural(
            "0x1::code",
            "publish_package_txn",
            [],
            [BCS.bcsSerializeBytes(moduleBytes)]
          )
        );

        const txnRequest = await this.client.generateTransaction(this.account.address(), payload);
        const signedTxn = await this.client.signTransaction(this.account, txnRequest);
        const txnResult = await this.client.submitTransaction(signedTxn);
        
        await this.client.waitForTransaction(txnResult.hash);
        
        deployedAddresses[moduleName] = this.account.address().hex();
        console.log(`‚úÖ ${moduleName} deployed at: ${this.account.address().hex()}`);
        
      } catch (error) {
        console.error(`‚ùå Failed to deploy ${moduleName}:`, error);
      }
    }

    return deployedAddresses;
  }

  async initializeContracts(deployedAddresses: Record<string, string>) {
    console.log('üöÄ Initializing contracts...');

    // Initialize Payment Router
    if (deployedAddresses.payment_router) {
      try {
        const payload = new TxnBuilderTypes.TransactionPayloadEntryFunction(
          TxnBuilderTypes.EntryFunction.natural(
            `${deployedAddresses.payment_router}::payment_router`,
            "initialize",
            [],
            []
          )
        );

        const txnRequest = await this.client.generateTransaction(this.account.address(), payload);
        const signedTxn = await this.client.signTransaction(this.account, txnRequest);
        const txnResult = await this.client.submitTransaction(signedTxn);
        
        await this.client.waitForTransaction(txnResult.hash);
        console.log('‚úÖ Payment Router initialized');
      } catch (error) {
        console.error('‚ùå Failed to initialize Payment Router:', error);
      }
    }

    // Initialize other contracts...
    // Similar initialization for forex_engine, treasury_vault, etc.
  }

  async generateEnvFile(deployedAddresses: Record<string, string>) {
    console.log('üìù Generating environment configuration...');

    const envContent = `# FlowPay Contract Addresses - Generated ${new Date().toISOString()}
NEXT_PUBLIC_FLOWPAY_PAYMENT_ROUTER=${deployedAddresses.payment_router || ''}
NEXT_PUBLIC_FLOWPAY_FOREX_ENGINE=${deployedAddresses.forex_engine || ''}
NEXT_PUBLIC_FLOWPAY_TREASURY_VAULT=${deployedAddresses.treasury_vault || ''}
NEXT_PUBLIC_FLOWPAY_COMPLIANCE_ORACLE=${deployedAddresses.compliance_oracle || ''}
NEXT_PUBLIC_FLOWPAY_SETTLEMENT_BRIDGE=${deployedAddresses.settlement_bridge || ''}

# Deployment Info
FLOWPAY_DEPLOYER_ADDRESS=${this.account.address().hex()}
FLOWPAY_NETWORK=testnet
FLOWPAY_DEPLOYED_AT=${new Date().toISOString()}
`;

    const envPath = path.join(__dirname, '../.env.contracts');
    fs.writeFileSync(envPath, envContent);
    console.log('‚úÖ Contract addresses saved to .env.contracts');
    
    // Also update .env.local
    const localEnvPath = path.join(__dirname, '../.env.local');
    if (fs.existsSync(localEnvPath)) {
      let localEnv = fs.readFileSync(localEnvPath, 'utf8');
      
      // Update contract addresses
      Object.entries(deployedAddresses).forEach(([module, address]) => {
        const envVar = `NEXT_PUBLIC_FLOWPAY_${module.toUpperCase()}`;
        const regex = new RegExp(`^${envVar}=.*$`, 'm');
        
        if (regex.test(localEnv)) {
          localEnv = localEnv.replace(regex, `${envVar}=${address}`);
        } else {
          localEnv += `\n${envVar}=${address}`;
        }
      });
      
      fs.writeFileSync(localEnvPath, localEnv);
      console.log('‚úÖ Updated .env.local with contract addresses');
    }
  }

  async deploy() {
    console.log('üöÄ Starting FlowPay deployment...');
    console.log('üåê Network: Aptos Testnet');
    console.log('üìç Deployer:', this.account.address().hex());
    
    try {
      await this.fundAccount();
      const deployedAddresses = await this.compileAndDeploy();
      await this.initializeContracts(deployedAddresses);
      await this.generateEnvFile(deployedAddresses);
      
      console.log('üéâ FlowPay deployment completed successfully!');
      console.log('üìã Deployed contracts:');
      Object.entries(deployedAddresses).forEach(([module, address]) => {
        console.log(`   ${module}: ${address}`);
      });
      
      console.log('\nüîó Next steps:');
      console.log('1. Update your .env.local with the contract addresses');
      console.log('2. Restart your development server');
      console.log('3. Test the application with real on-chain functionality');
      
    } catch (error) {
      console.error('‚ùå Deployment failed:', error);
      process.exit(1);
    }
  }
}

// Run deployment
if (require.main === module) {
  const deployer = new FlowPayDeployer();
  deployer.deploy().catch(console.error);
}

export { FlowPayDeployer };